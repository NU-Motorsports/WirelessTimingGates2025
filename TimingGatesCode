#include <LiquidCrystal.h>
int modeButton = 5;//Button Pin
int Sensor_0 = 7; //Sensor pin  
int Sensor_1 = 6; //Sensor pin  
int start_sensor; // Used to track which sesnor started 
int end_sensor; //Used to track which sensor must end
unsigned long StartTrigger = 0; //Start time
unsigned long timeBetween = 0; //Time between triggers(output time)
bool Timer_Started = false; //checks whether the timer is running
const int rs = 13, en = 12, d4 = 11, d5 = 10, d6 = 9, d7 = 8; //Ripped code from online for the LCD initialization so I got no clue. (Fuck reading documentation)
LiquidCrystal lcd(rs, en, d4, d5, d6, d7);//initializes the LCD screen as an object with the correct pin assignments.
float saved_time = 0; //previously logged time
int current_Mode = 0; //There will be two modes: 0 is timing gates, 1 will be the Lap timer


//sets pins for sensors and button, and sets LCD to say the timing gats are ready
void setup() {
  Serial.begin(9600);
  pinMode(Sensor_1, INPUT_PULLUP);
  pinMode(Sensor_0, INPUT_PULLUP);
  lcd.begin(16, 2); //starts the LCD screen as a 16 by 2 display(16 characters wide 2 high)
  pinMode(modeButton, INPUT_PULLUP);
  lcd.setCursor(0, 0);
  lcd.print("Gates Ready.");
}


//The main loop checks if the state is changed and then runs the code for either one depending on the state.
void loop() {
  ChangeState();
  if (!current_Mode){ 
    TimingGates(); 
  }
  else {
    LapTime();
  }
  

}

//timing gate function. Essentially checks if a gate was tripped. If it was then wait for the other to trip and then run the end function
void TimingGates(){

//Checks if else checks which sensor is trippeed and logs that to know which on to wait for
  if (digitalRead(Sensor_0) == HIGH && !Timer_Started){ 
    
    TimerStarted();
    start_sensor = Sensor_0;
    end_sensor = Sensor_1;

  }
  else if(digitalRead(Sensor_1) == HIGH && !Timer_Started){ 
    TimerStarted();
    start_sensor = Sensor_1;
    end_sensor = Sensor_0;
  }
//once the other is tripped end the timer and print onto the LCD screen
  if (digitalRead(end_sensor) == HIGH && Timer_Started){
    TimerEnded();
    delay(1000);
    lcd.setCursor(0, 0);
    lcd.print("Gates Ready.");
  }

}

//Cleans up between the changing of modes. Removes the variables that are stored and clears the LCD screen. AS well gives a 1 second delay for hold time
void ModeChangeCleanup(){
  lcd.clear();
  Timer_Started = false;
  saved_time = 0;
  delay(1000); 
}


//Changes the state using a modulo to switch between 1 and 0 when the button is pressed
void ChangeState(){

  if (!digitalRead(modeButton)){
    current_Mode = (current_Mode + 1) % 2;
    lcd.setCursor(0, 0);

//Runs the cleanup function to ensure no issues changing
    ModeChangeCleanup(); 

//sets up screen for the running function
    if (current_Mode == 0){
      lcd.print("Gates Ready.");
      Serial.print("Gates Ready.");
    }
    else{
      lcd.print("Lap Time Ready.");
      Serial.print("Lap Time Ready.");
    }
  }
}

//laptime function essentially the gate time function however only triggers off of one sensor and restarts immediatly after being triggered
void LapTime(){ 
  if(digitalRead(Sensor_1) == HIGH && !Timer_Started){
    TimerStarted();
    delay(1000);
  }
  if(digitalRead(Sensor_1) == HIGH && Timer_Started){
    TimerEnded();
    TimerStarted();
    delay(1000);
  }
}
void TimerStarted() {//For when the timer is started
    Serial.print("Timer started as a ");
    Serial.print(current_Mode);
    Timer_Started = true; //Shows that the timing is running
    StartTrigger = millis(); //Sets the start timer value for later calculation
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Active."); //Clears and writes to the LCD that it is currently running
    lcd.setCursor(0, 1);
    lcd.print(saved_time);
    lcd.print(" Seconds");
}

void TimerEnded() { //Runs when the timer ends
    Serial.print("Timer Ended with a time of:");
    Timer_Started = false;
    unsigned long now = millis();
    timeBetween = now - StartTrigger;
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Not Active.");
    lcd.setCursor(0, 1);
    saved_time = (float)timeBetween/1000;
    lcd.print(saved_time);
    lcd.print(" Seconds");
    Serial.print(saved_time);
}
// if (Timer_Started){
//   unsigned short now = millis();
  //   timeBetween = now - StartTrigger;
  //   float time_float = (float)timeBetween/1000;
  //   lcd.setCursor(0, 0);
  //   lcd.print(time_float);
  //   lcd.print(" Seconds");

  // }    
//void LapTimeCleanup(){ //Makes sure there arent any unresolved variables
//  delay(500);//Half a second for someone to release the button after pressing
//}

    // if (saved_time != 0){
    //   lcd.setCursor(0, 2);
    //   lcd.print("Prev. time: ");
    //   lcd.print(saved_time);
    // lcd.setCursor(0, 0);
    // // lcd.print("0 Seconds");
    // }
